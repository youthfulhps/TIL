## let, const의 블록스코프와 var

### 1. let/const 블록 스코프 vs var 함수 스코프
var의 경우 함수 스코프를 가진다. 함수 스코프의 경우 함수 내부만을 스코프로 인정하기 때문에 전역 함수 외부(블록 포함)에서 선언된 변수는 전역 변수가 된다. 
(for문에서 사용된 변수가 전역 스코프에서 참조됨) 함수 스코프의 경우 중복된 변수 선언이나 의도치 않은 값 변경과 같은 사이드 이펙트를 발생할 확률이 높다.

let/const의 경우 블록 스코프를 갖는다. 모든 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외에서 참조할 수 없다.

### 2. 호이스팅

var의 경우 선언문 이전에 참조가 가능하지만, let/const의 경우 참조가 불가능하다. 가령 변수를 선언하게 되면 3가지 단계를 걸쳐 변수가 생성된다.

- 선언 단계, 변수를 실행 컨텍스트의 변수 객체에 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 즉 해당 변수명이 검색 대상에 추가된 것 
- 초기화 단계, 변수 객체에 등록된 변수를 위한 공간 메모리를 확보한다. 이때 변수는 undefined로 초기화된다.
- 할당 단계, undefined로 초기화된 변수에 실제 값을 할당한다.

해당 스코프의 실행 컨텍스트가 생성될 때 스코프 내에 선언된 변수는 모두 변수 객체에 등록되게 된다. 즉 var, let, const가 모두 호이스팅 동작이
일어난다.

여기서, var의 경우 선언 단계와 초기화 단계가 한번에 이루어진다. 즉, 선언과 동시에 초기화가 이루어져 변수 선언문 이전에 해당 변수를 참조하여도 이미 초기화되어
스코프의 변수 객체에 등록되어 있고 초기화되어 있어 에러가 발생하지 않는다. (다만, 할당문을 만나기 전까지는 undefined)

반면 let/const의 경우 선언 단계가 먼저 이루어지고, 할당문을 만났을 때 초기화와 할당이 이루어진다. 즉, 할당문 이전에 해당 변수를 참조하려 한다면, 
아직 공간 메모리가 확보되지 않은 변수로 참조할 수 없게 된다. (해당 스코프의 실행 컨텍스트 생성 시 변수 객체에 등록(호이스팅)되어 존재의 유무는 알 수 있지만,
할당문 이전에는 아직 초기화되지 않은 변수로 참조가 불가능한 상태에 빠진다. 즉, 스코프 시작 시점부터 해당 변수의 초기화 시작 시점까지의 구간동안 참조가 불가능하며
이를 '일시적 사각지대'라고 부른다.)








