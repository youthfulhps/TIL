# 아이템52. 테스팅 타입의 함정에 주의하기

프로젝트를 공개하려면 테스트 코드를 작성하는 것은 필수이며,
타입선언에도 테스트를 거쳐야 한다. 그러나 타입 선언을 테스트하기에는 매우 어렵다.

결국, 테스트 시 타입 단언문을 사용하는 경우가 많지만, 많은 문제들이 도사리고 있다.

궁극적으로는 dtslint 또는 타입 시스템 외부에서 타입을 검사하는 유사한 도구를
사용하는 것이 안전하고 간단하다.

map 함수의 타입 선언을 작성한다고 가정해보자.

```ts
declare function map<U, V>(array: U[], fn: (u: U) => V): V[];
```

타입 선언이 예상한 타입으로 결과를 내는지 체크할 수 있는 한 가지 방법은
함수를 호출하는 테스트 파일을 작성하는 것이지만 허점이 존재한다.

```ts
map(["2017", "2018", "2019"], (v) => Number(v));
```

map의 첫 번째 매개변수에 배열이 아닌 단일 값이 있었다면,
매개변수의 타입에 대한 오류는 잡을 수 있다. 그러나 반환값에 대한
체크가 누락되어 있기 때문에 완전한 테스트라고 할 수 없다.

동일한 케이스로 square 함수의 런타임 동작을 테스트한다면
다음과 같은 테스트 코드가 된다.

```ts
test("square a number", () => {
  square(1);
  square(2);
});
```

이 테스트 코드는 square 함수의 '실행'에서 오류가 발생하지 않는지만
체크한다. 그런데, 반환값에 대해서는 체크하지 않기 때문에
실제로는 실행의 결과에 대한 테스트는 하지 않는 것이 된다.
따라서, square 함수의 구현이 잘못되어도 테스트는 통과하게 된다.

**함수를 실행하는 테스트 코드가 의미 없는 것은 아니지만,
실제로 반환 타입을 체크하는 것이 훨씬 좋은 테스트 코드이다.**

반환값을 특정 타입의 변수에 할당하여 간단히 반환 타입을 체크할 수 있는
방법이 있다.

```ts
const lengths: number[] = map(["john", "paul"], (name) => name.length);
```

`number[]`를 lengths 변수의 타입으로 명시한 것은 일반적으로
불필요한 타입 선언에 해당하지만, 테스트 코드 관점에서는 중요한 역할을 하고 있다.
number[] 타입 선언은 map 함수의 반환 타입이 number[]임을 보장한다.

실제도 DefinitelyTyped에도 테스팅을 위해 위와 같은 방법을 사용하는 케이스들이 많다.
하지만, 테스팅을 위해 타입을 할당하는 방법에도 두 가지 문제점이 있다.

- 불필요한 변수를 만들어야 한다.

미사용 변수에 대한 경고를 피하기 위해 린팅 규칙을 임시 비활성화해야 한다.
그래서, 일반적인 해결책은 변수를 도입하는 대신 헬퍼 함수를 정의한다.

```ts
function assertType<T>(x: T) {}

assertType<number[]>(map(["john", "paul"], (name) => name.length));
```

하지만, 두 번째 문제가 남아있다.

- 두 타입이 동일한지 체크하는 것이 아니라 할당 가능성을
  체크하고 있다.

```ts
const n = 12;
assertType<number>(n); //good
```

그러나, 객체의 타입을 체크하는 경우를 살펴보면 문제를
발견하게 된다.

```ts
const beatles = ["john", "paul", "george", "ringo"];
assertType<{ name: string }[]>(
  map(beatles, (name) => ({
    name,
    inYellowSubmarine: name === "ringo",
  }))
); // OK
```

(작성 중..)
