# 아이템46. 타입 선언과 관련된 세 가지 버전 이해하기

의존성 관리는 개발자에게 매우 힘든 일이다. 아마 단순히 라이브러리를 프로젝트에 추가해서
사용할 뿐 라이브러리의 전이적 의존성이 호환되는지 깊게 생각하지 않았을 것이다.

그런데, 실제로는 타입스크립트는 의존성 관리를 오히려 복잡하게 만든다. 타입스크립트를 사용하면
세 가지 사항이 추가로 고려되어야 하기 때문이다.

- 라이브러리의 버전
- 타입 선언(@types)의 버전
- 타입스크립트의 버전

이 세 가지 버전 중 하나라도 맞지 않으면, 의존성과 상관없어 보이는 엉뚱한 곳에서 오류를 발생시킬 수 있다.
**발생한 오류를 해결하고자 한다면, 타입스크립트 라이브러리 관리의 복잡한 매커니즘을 모두 이해하고 있어야 한다.**

타입스크립트에서 일반적으로 의존성을 사용하는 방식은 특정 라이브러리를 dependencies로 설치하고,
타입정보는 devDependencies로 설치하는 것부터 시작된다.

```shell
$ npm install react
+ react@16.8.6
$ npm install --save-dev @types/react
+ @types/react@16.8.19
```

(일반적으로 버전의 구성은 {메이저버전}.{마이너버전}.{패치버전} 으로 이루어져 있다.)

위의 의존성은 메이저 버전과 마이너 버전이 일치하지만, 패치버전(.6, .19)이 일치하지 않는다.
타입 선언 자체에도 버그나 누락이 존재할 수 있고, @types 모듈의 패치 버전은 버그나 누락으로 인한
수정과 추가에 따라 업데이트된 것이다.

그러나 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 몇 가지 문제점이 있다.

**라이브러리를 업데이트했지만, 실수로 타입 선언은 업데이트하지 않는 경우가 발생한다.**
이런 경우 라이브러리 업데이트와 관련된 새로운 기능을 사용하려 할 때 타입 오류가 발생할 수 있다. 특히
하위 호환성이 깨지는 변경이 있었다면, 코드가 타입 체커를 통과하더라도 런타임에 오류가 발생할 수 있다.

이런 경우, 일반적으로 타입 선언도 업데이트하여 라이브러리와 버전을 맞추는 것이 해결책이나, 업데이트해야 할
타입 선언의 버전이 아직 준비되지 않은 경우라면 두 가지 선택지를 고민해야 한다.

- 보강 기법을 활용하여 사용하려는 새 함수와 매서드의 타입 정보를 프로젝트 자체적으로 추가한다.
- 타입 선언의 업데이트를 직접 작성하고 공개하여 커뮤니티에 기여한다.

또 다른 문제점으로는, 라이브러리보다 타입 선언의 버전이 최신인 경우이다. 이런 경우는 타입 정보 없이 라이브러리를
사용해 오다가 (가령, declare module를 통한 any 타입 선언) 타입 선언을 설치하려고 할 때 뒤는게 오류가 발생한다.

이런 경우, 첫 번째 문제와 상황이 비슷하지만 버전의 대소 관계가 반대이다. 타입 체커는 최신 API를 기준으로
코드를 검사하게 되지만, 런타임에 실제로 쓰이는 것은 과거 버전이다. 해결책으로는 라이브러리와 타입 선언의 버전이 맞도록
라이브러리 버전을 올리거나 타입 선언의 버전을 내리는 것이다.

세 번째 문제로는 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우이다.
로대시, 리엑트, 람다 같은 유명 자바스크립트 라이브러리의 타입 정보를 더 정확하게 표현하기 위해서 타입스크립트에서 타입 시스템이
개선되고 버전이 올라가게 된다. 즉, 이러한 라이브러리들의 최신 타입 정보를 얻기 위해서는 당연히 타입스크립트의 최신 버전을 사용해야 한다.

현재 프로젝트보다 라이브러리에게 필요한 타입스크립트 버전이 높은 상황이라면, @types 선언 자체에서 타입 오류가 발생한다.
이 오류를 해결하려면 프로젝트의 타입스크립트 버전을 올리거나, 라이브러리 타입 선언의 버전을 원래대로 돌리거나,
declare module 선언으로 라이브러리의 타입 정보를 없애 버리면 된다.

종종 라이브러리에서 typesVersions를 통해 타입스크립트 버전별로 다른 타입 선언을 제공하는 방법도 있지만, 실제로는 매우 드물다.
DefinitelyTyped의 라이브러리 중 1% 미만이 typesVersions을 제공한다.

네 번째 문제로는, @types 의존성이 중복될 수 있다. @types/foo와 @types/bar에 의존하는 경우가 있는데, @types/bar가
현재 프로젝트와 호환되지 않는 버전의 @types/foo에 의존한다면, npm은 중첩된 폴더에 별도로 해당 버전을 설치하여
문제를 해결하고자 한다. 런타임에서 사용되는 모듈이라면 괜찮을 수 있지만, 전역 네임스페이스에 있는 타입 선언 모듈이라면
대부분 문제가 발생하는데, 전역 네임 스페이스에 타입 선언이 존재하면 중복된 선언 또는 선언이 병합 될 수 없다는 오류를 나타내게 된다.

이런 상황이라면, `npm ls @types/foo`를 실행하여 어디서 타입 중복이 발생했는지 추적할 수 있다. 해결책은 보통 @types/foo를
업데이트하거나, @types/bar를 업데이트해서 서로 버전이 호환되도록 하는 것이다. 그러나, @types이 전이 의존성을 가지도록
만드는 것 또한 문제를 발생시킨다. 만약, 타입 선언을 작성하고 공개하려고 한다면, 아이템 51의 문제들을 피해야 한다.

타입스크립트로 작성된 라이브러리들은 자체적으로 타입 선언을 포함하게 된다. 자체적인 타입 선언은 보통 package.json의 types 필드에서
.d.ts 파일을 가리키도록 되어 있다.

```json
{
  "name": "left-pad",
  "version": "1.3.0",
  "description": "~",
  "main": "index.js",
  "types": "index.d.ts"
  //...
}
```

하지만, 여기서 "types": "index.d.ts"를 추가하면 모든 문제가 해결되는 것은 아니다. 번들링하여 타입 선언을 포함하는 경우,
특히 라이브러리가 타입스크립트로 작성되고, 컴파일러를 통해 타입 선언이 생성된 경우라면 버전 불일치 문제를 해결하기는 하나,
번들링 방식은 부수적인 문제를 가지고 있다.

- 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작했지만, 타입스크립트 버전이
  올라가면서 오류가 발생하는 경우에 문제가 된다. 번들된 타입에서는 @types 버전 선택이 불가능하다.

- 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 이존한다면 문제가 된다. 보톤 의존성이 devDependencies에 들어간다.
  그러나, 프로젝트를 공개하여 다른 사용자가 설치하게 되면, devDependencies가 설치되지 않게 되고, 타입 오류가 발생한다.

- 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우에는 과거 버전으로 돌아가서 패치 업데이트를 해야 한다.

- 타입 선언의 패치 업데이트를 자주 하기 어렵다. 라이브러리 자체보다 타입 선언에 대한 패치 업데이트가 react의 경우 많다.

타입스크립트에서 의존성을 관리한다는 것은 쉽지 않지만, 잘 관리한다면 그에 따른 보상 또한 존재한다.

잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법을 배우는 데 도움이 되고, 생산성 역시 크게 향상시킬 수 있다.
만약, 의존성 관리에 문제가 생기면, 아이템46을 기억해야 한다.

라이브러리를 공개하려는 경우, 타입 선언을 자체적으로 포함하는 것과 타입 정보만 분리하여 DefinitelyTyped에 공개하는 것의 장단점을
비교해 보아야 한다. 공식적인 권장 사항은 라이브러리가 타입스크립트로 작성된 경우만 타입 선언을 라이브러리에 포함하는 것이다.
